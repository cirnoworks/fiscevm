\C#ifdef FY_ENGINE_HEADER
\C#define Cell fy_stack_item
\C
\C
\CFY_HOT fy_int FY_ENGINE_NAME(
\C    fy_context *context,
\C    fy_thread *thread,
\C    fy_frame *frame,
\C    fy_int ops,
\C    fy_exception *exception,
\C    fy_e2_label_holder **out_labels) {
\C#ifndef FY_LATE_DECLARATION
\C#ifdef USE_CFA
\C  register fy_e2_label cfa;
\C#endif
\C  register fy_instruction *ipp;
\C#ifdef FY_USE_TOS
\C  register fy_stack_item sppTOS;
\C#endif
\C  register fy_stack_item *spp;
\C
\C  fy_instruction *instructions;
\C  register fy_stack_item *sbase;
\C
\C
\C  fy_method *method = NULL;
\C#endif
\C
\C#ifndef FY_LATE_DECLARATION
\C  fy_uint i1, i2, i3, i4, i5, i6, ir1, ir2, ir3, ir4, ir5, ir6;
\C#endif
\C
\C  static fy_e2_label_holder labels[] = {
\C#undef FY_ENGINE_HEADER
\C#include "fisce-labels.i"
\C#define FY_ENGINE_HEADER
\C      {0, -1}
\C  };
\C#ifdef MORE_VARS
\C  MORE_VARS
\C#endif
\C
\C#ifdef VM_DEBUG
\C  FILE *vm_out = stdout;
\C  const fy_uint vm_debug = 1;
\C#endif
\C
\C
\C
\C  if(unlikely(thread == NULL)){
\C    *out_labels = labels;
\C    return 0;
\C  }else{
\C#ifdef FY_LATE_DECLARATION
\C#ifdef USE_CFA
\C  register fy_e2_label cfa;
\C#endif
\C  register fy_instruction *ipp;
\C#ifdef FY_USE_TOS
\C  register fy_stack_item sppTOS;
\C#endif
\C  register fy_stack_item *spp;
\C
\C  fy_instruction *instructions;
\C  register fy_stack_item *sbase;
\C
\C  fy_method *method = NULL;
\C#endif
\C
\C
\C  method = frame->method;
\C  instructions = method->instructions;
\C  sbase = frame->baseSpp;
\C
\C#ifdef VM_DEBUG
\C  if(vm_debug){
\C    fprintf(vm_out, "\nInvoking: ");
\C    fy_strFPrint(vm_out, method->uniqueName);
\C    fprintf(vm_out, " pc = %"FY_PRINT32"d + %"FY_PRINT32"d\n sb = %"FY_PRINT32"d", frame->lpc, frame->pcofs, FY_PDIFF(fy_stack_item, sbase, thread->stack));
\C    if(frame->lpc + frame->pcofs == FY_IP_begin){
\C#ifndef FY_LATE_DECLARATION
\C      fy_uint i1, i2;
\C      fprintf(vm_out, "[")
\C      i2 = method->max_locals + method->max_stack;
\C      for(i1 = 0; i1 < i2; i1++){
\C        printarg_i(sbase + i1);
\C        if(i1 < i2 - 1) fputs(", ", vm_out);
\C      }
\C      fputs("]\n", vm_out);
\C#endif
\C    }
\C  }
\C#endif
\C
\C  if ((method->access_flags & FY_ACC_CLINIT) && frame->lpc + frame->pcofs == FY_IP_begin) {
\C#ifdef VM_DEBUG
\C    if(vm_debug){
\C      fprintf(vm_out, "Checking clinit for: ");
\C      fy_strFPrint(vm_out, method->uniqueName);
\C      fprintf(vm_out, "\n");
\C    }
\C#endif
\C    //!CLINIT
\C    ipp = method->instructions;
\C    spp = frame->baseSpp + method->max_locals;
\C    FY_ENGINE_CLINIT(method->owner, 0)
\C  }
\C
\C  
\C  ENGINE_ENTER;
\C#endif

\E store-optimization off

\ stack definitions:
\E stack data-stack spp fy_stack_item
\E : sp-access-transform ( itemnum -- index ) negate 1- ;
\E ' sp-access-transform ' data-stack >body stack-access-transform !

\ type prefix definitions:
\E s" fy_uint"   single data-stack type-prefix i
\E s" fy_float" single data-stack type-prefix f
\E s" fy_double" double data-stack type-prefix d
\E s" fy_ulong" double data-stack type-prefix l

\ ####### ######  #######   ###   #     #   ###   ####### #######
\ #     # #     #    #       #    ##   ##    #         #  #
\ #     # #     #    #       #    # # # #    #        #   #
\ #     # ######     #       #    #  #  #    #       #    #####
\ #     # #          #       #    #     #    #      #     #
\ #     # #          #       #    #     #    #     #      #
\ ####### #          #      ###   #     #   ###   ####### #######

iload ( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #iload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalInt(CURR_INST.params.int_params.param1, ir);
}

iload1 ( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #iload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalInt(CURR_INST.params.int_params.param1, ir);
}

iload2 ( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #iload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalInt(CURR_INST.params.int_params.param1, ir);
}

iload3 ( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #iload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalInt(CURR_INST.params.int_params.param1, ir);
}

iload4 ( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #iload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalInt(CURR_INST.params.int_params.param1, ir);
}

iload5 ( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #iload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalInt(CURR_INST.params.int_params.param1, ir);
}

iload6 ( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #iload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalInt(CURR_INST.params.int_params.param1, ir);
}

iload7 ( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #iload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalInt(CURR_INST.params.int_params.param1, ir);
}

iload8 ( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #iload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalInt(CURR_INST.params.int_params.param1, ir);
}

iaload (i1 i2 -- ir)
{
  ir = fy_heapGetArrayInt(context, i1, i2, exception);
  FY_THEH()
}

iadd (i1 i2 -- ir)
{
  ir = i1 + i2;
}

nop ( -- )
;


\ ######  ######    ###   #     #    #    ####### #######
\ #     # #     #    #    #     #   # #      #    #
\ #     # #     #    #    #     #  #   #     #    #
\ ######  ######     #    #     # #     #    #    #####
\ #       #   #      #     #   #  #######    #    #
\ #       #    #     #      # #   #     #    #    #
\ #       #     #   ###      #    #     #    #    #######

getfield_n (i1 -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getfield %s from #%"FY_PRINT32"d# ", CURR_INST.params.field->utf8Name, i1);
  }
#endif
  ir = fy_heapGetFieldInt(context, i1, CURR_INST.params.field, exception);
  FY_THEH()
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #value=%"FY_PRINT32"d# ", ir);
  }
#endif
}

putfield_n (i1 i2 --)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #putfield %s to #%"FY_PRINT32"d value=%"FY_PRINT32"d# ", CURR_INST.params.field->utf8Name, i1, i2);
  }
#endif
  fy_heapPutFieldInt(context, i1, CURR_INST.params.field, i2, exception);
  FY_THEH()
}

getfield_nx (i1 -- lr)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getfield %s from #%"FY_PRINT32"d# ", CURR_INST.params.field->utf8Name, i1);
  }
#endif
  lr = fy_heapGetFieldLong(context, i1, CURR_INST.params.field, exception);
  FY_THEH()
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #value=%"FY_PRINT64"d# ", lr);
  }
#endif
}

putfield_nx (i1 l1 --)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #putfield %s to #%"FY_PRINT32"d value=%"FY_PRINT64"d# ", CURR_INST.params.field->utf8Name, i1, l1);
  }
#endif
  fy_heapPutFieldLong(context, i1, CURR_INST.params.field, l1, exception);
  FY_THEH()
}

getstatic_n( -- ir)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getstatic %p# ", CURR_INST.params.isfield);
  }
#endif
  ir = CURR_INST.params.isfield[0];
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getstatic %p value=%"FY_PRINT32"d# ", CURR_INST.params.isfield, ir);
  }
#endif
}

putstatic_n(i1 -- )
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #putstatic %p value=%"FY_PRINT32"d# ", CURR_INST.params.isfield, i1);
  }
#endif
  CURR_INST.params.isfield[0] = i1;
}

getstatic_nx( -- ir1 ir2)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getstatic %p# ", CURR_INST.params.isfield);
  }
#endif
  ir1 = CURR_INST.params.isfield[0];
  ir2 = CURR_INST.params.isfield[1];
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getstatic %p value = %"FY_PRINT64"d# ", CURR_INST.params.isfield, fy_I2TOL(ir1, ir2));
  }
#endif
}

putstatic_nx(i1 i2 -- )
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #putstatic %p value=%"FY_PRINT64"d# ", CURR_INST.params.isfield, fy_I2TOL(i1, i2));
  }
#endif
  CURR_INST.params.isfield[0] = i1;
  CURR_INST.params.isfield[1] = i2;
}

\ #       #######  #####     #    #
\ #       #     # #     #   # #   #
\ #       #     # #        #   #  #
\ #       #     # #       #     # #
\ #       #     # #       ####### #
\ #       #     # #     # #     # #
\ ####### #######  #####  #     # #######



istore (i1 -- )
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #istore_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadPutLocalInt(CURR_INST.params.int_params.param1, i1);
}

iinc ( -- )
{
  sbase[CURR_INST.params.int_params.param1].uvalue += CURR_INST.params.int_params.param2;
}


\  #####  #######    #     #####  #    #
\ #     #    #      # #   #     # #   #
\ #          #     #   #  #       #  #
\  #####     #    #     # #       ###
\       #    #    ####### #       #  #
\ #     #    #    #     # #     # #   #
\  #####     #    #     #  #####  #    #

\ CONST

sipush ( -- ir)
{
  ir = CURR_INST.params.int_params.param1;
}

slpush ( -- ir1 ir2)
{
  ir1 = CURR_INST.params.int_params.param1;
  ir2 = CURR_INST.params.int_params.param2;
}

\ DUP (common)

dup (i1 -- ir1 ir2)
{
  ir1 = ir2 = i1;
}

\ CALC

isub (i1 i2 -- ir)
{
  ir = i1 - i2;
}

imul (i1 i2 -- ir)
{
  ir = (fy_uint)((fy_int)i1 * (fy_int)i2);
}

idiv (i1 i2 -- ir)
{
  if(unlikely(i2 == 0)){
    fy_fault(exception, FY_EXCEPTION_ARITHMETIC, "Divided by zero!");
    FY_THEH()
    ir = 0;
  } else {
    ir = ((fy_int)i1) / ((fy_int)i2);
  }
}

irem (i1 i2 -- ir)
{
  if(unlikely(i2 == 0)){
    fy_fault(exception, FY_EXCEPTION_ARITHMETIC, "Divided by zero!");
    FY_THEH()
    ir = 0;
  } else {
    ir = ((fy_int)i1) % ((fy_int)i2);
  }
}

ineg (i1 -- ir)
{
  ir = -i1;
}

iand (i1 i2 -- ir)
{
  ir = i1 & i2;
}

ior (i1 i2 -- ir)
{
  ir = i1 | i2;
}

ixor (i1 i2 -- ir)
{
  ir = i1 ^ i2;
}

ishl (i1 i2 -- ir)
{
  ir = i1 << i2;
}

ishr (i1 i2 -- ir)
{
  ir = ((fy_int)i1) >> ((fy_int)i2);
}

iushr (i1 i2 -- ir)
{
  ir = i1 >> i2;
}

fadd (f1 f2 -- fr)
{
  fr = f1 + f2;
}

fsub (f1 f2 -- fr)
{
  fr = f1 - f2;
}

fmul (f1 f2 -- fr)
{
  fr = f1 * f2;
}

fdiv (f1 f2 -- fr)
{
  fr = f1 / f2;
}

frem (f1 f2 -- fr)
{
  if(f2 == 0){
    fr = 0.0 / f2;
  } else {
    fr = f1 - floor(f1 / f2) * f2;
  }
}

fneg (f1 -- fr)
{
  fr = -f1;
}

fcmpg (f1 f2 -- ir)
{
  if (unlikely(fy_isnand(f2) || fy_isnand(f1))) {
    ir = 1;
  } else {
    ir = f1 == f2 ? 0 : (f1 - f2 > 0) ? 1 : -1;
  }
}

fcmpl (f1 f2 -- ir)
{
  if (unlikely(fy_isnand(f2) || fy_isnand(f1))) {
    ir = -1;
  } else {
    ir = f1 == f2 ? 0 : (f1 - f2 > 0) ? 1 : -1;
  }
}

\ DUP (not so common)
dup_x1 (i1 i2 -- ir1 ir2 ir3)
{
  ir1 = i2;
  ir2 = i1;
  ir3 = i2;
}

dup_x2 (i1 i2 i3 -- ir1 ir2 ir3 ir4)
{
  ir1 = i3;
  ir2 = i1;
  ir3 = i2;
  ir4 = i3;
}

dup2 (i1 i2 -- ir1 ir2 ir3 ir4)
{
  ir3 = ir1 = i1;
  ir4 = ir2 = i2;
}

dup2_x1 (i1 i2 i3 -- ir1 ir2 ir3 ir4 ir5)
{
  ir1 = i2;
  ir2 = i3;
  ir3 = i1;
  ir4 = i2;
  ir5 = i3;
}

dup2_x2 (i1 i2 i3 i4 -- ir1 ir2 ir3 ir4 ir5 ir6)
{
  ir1 = i3;
  ir2 = i4;
  ir3 = i1;
  ir4 = i2;
  ir5 = i3;
  ir6 = i4;
}

swap (i1 i2 -- ir1 ir2)
{
  ir1 = i2;
  ir2 = i1;
}

\ CONVERT

d2f (d1 -- fr)
{
  fr = (fy_float)d1;
}

d2i (d1 -- ir)
{
  ir = (fy_int)d1;
}

d2l (d1 -- lr)
{
  lr = (fy_long)d1;
}

f2d (f1 -- dr)
{
  dr = f1;
}

f2i (f1 -- ir)
{
  ir = (fy_int)f1;
}

f2l (f1 -- lr)
{
  lr = (fy_long)f1;
}

i2b (i1 -- ir)
{
  ir = (fy_byte)i1;
}

i2c (i1 -- ir)
{
  ir = i1 & 0xffff;
}

i2d (i1 -- dr)
{
  dr = (fy_int)i1;
}

i2f (i1 -- fr)
{
  fr = (fy_int)i1;
}

i2l (i1 -- lr)
{
  lr = (fy_int)i1;
}

i2s (i1 -- ir)
{
  ir = (fy_short)i1;
}

l2d (l1 -- dr)
{
  dr = (fy_long)l1;
}

l2f (l1 -- fr)
{
  fr = (fy_long)l1;
}

l2i (l1 -- ir)
{
  ir = (fy_uint)l1;
}

lload ( -- lr)
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #lload_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadGetLocalLong(CURR_INST.params.int_params.param1, lr);
}

lstore (l1 -- )
{
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #lstore_%"FY_PRINT32"d# ", CURR_INST.params.int_params.param1);
  }
#endif
  fy_threadPutLocalLong(CURR_INST.params.int_params.param1, l1);
}

ladd (l1 l2 -- lr)
{
  lr = l1 + l2;
}

lsub (l1 l2 -- lr)
{
  lr = l1 - l2;
}

lmul (l1 l2 -- lr)
{
  lr = (fy_long) l1 * (fy_long) l2;
}

ldiv (l1 l2 -- lr)
{
  if (unlikely(l2 == 0)) {
    fy_fault(exception, FY_EXCEPTION_ARITHMETIC, "Divided by zero!");
    FY_THEH()
  }
  lr = (fy_long) l1 / (fy_long) l2;
}

lrem (l1 l2 -- lr)
{
  if (unlikely(l2 == 0)) {
    fy_fault(exception, FY_EXCEPTION_ARITHMETIC, "Divided by zero!");
    FY_THEH()
  }
  lr = (fy_long) l1 % (fy_long) l2;
}

lneg (l1 -- lr)
{
  lr = -l1;
}

land (i1 i2 i3 i4 -- ir1 ir2)
{
  ir1 = i1 & i3;
  ir2 = i2 & i4;
}

lor (i1 i2 i3 i4 -- ir1 ir2)
{
  ir1 = i1 | i3;
  ir2 = i2 | i4;
}

lxor (i1 i2 i3 i4 -- ir1 ir2)
{
  ir1 = i1 ^ i3;
  ir2 = i2 ^ i4;
}

lcmp (l1 l2 -- ir)
{
  ir = l1 == l2 ? 0 : ((fy_long)l1 > (fy_long)l2 ? 1 : -1) ;
}

lshl (l1 i1 -- lr)
{
  lr = l1 << i1;
}

lshr (l1 i1 -- lr)
{
  lr = ((fy_long)l1) >> i1;
}

lushr (l1 i1 -- lr)
{
  lr = l1 >> i1;
}

\    #    ######  ######     #    #     #
\   # #   #     # #     #   # #    #   #
\  #   #  #     # #     #  #   #    # #
\ #     # ######  ######  #     #    #
\ ####### #   #   #   #   #######    #
\ #     # #    #  #    #  #     #    #
\ #     # #     # #     # #     #    #

arraylength (i1 -- ir)
{
  ir = fy_heapArrayLength(context, i1, exception);
  FY_THEH()
}

iastore (i1 i2 i3 -- )
{
  fy_heapPutArrayInt(context, i1, i2, i3, exception);
  FY_THEH()
}

baload (i1 i2 -- ir)
{ /*handle index -- value*/
  ir = fy_heapGetArrayByte(context, i1, i2, exception);
  FY_THEH()
}

bastore (i1 i2 i3 -- )
{ /*handle index value*/
  fy_heapPutArrayByte(context, i1, i2, (fy_byte) i3, exception);
  FY_THEH()
}

caload (i1 i2 -- ir)
{ /*index handle -- value*/
  ir = fy_heapGetArrayChar(context, i1, i2, exception);
  FY_THEH()
}

castore (i1 i2 i3 -- )
{ /*value index handle*/
  fy_heapPutArrayChar(context, i1, i2, (fy_char) i3, exception);
  FY_THEH()
}

saload (i1 i2 -- ir)
{ /*index handle -- value*/
  ir = fy_heapGetArrayShort(context, i1, i2, exception);
  FY_THEH()
}

sastore (i1 i2 i3 -- )
{ /*value index handle*/
  fy_heapPutArrayShort(context, i1, i2, (fy_short) i3, exception);
  FY_THEH()
}

laload (i1 i2 -- lr)
{
  lr = fy_heapGetArrayLong(context, i1, i2, exception);
  FY_THEH()
}

lastore (i1 i2 l1 -- )
{
  fy_heapPutArrayLong(context, i1, i2, l1, exception);
  FY_THEH()
}

anewarray (i1 -- ir)
{
  ir = fy_heapAllocateArrayWithContentType(context, CURR_INST.params.clazz, i1, exception);
  FY_THEH()
}

multianewarray ( -- ir)
{
  fy_class *clazz1;
  clazz1 = fy_vmLookupClassFromConstant(context, (ConstantClass*) method->owner->constantPools[CURR_INST.params.int_params.param1], exception);
  FY_THEH()
  spp -= CURR_INST.params.int_params.param2;
#ifdef VM_DEBUG
  if(vm_debug){
# ifdef FY_LATE_DECLARATION
    fy_int i1;
# endif
    fputc(' ', vm_out);
    for(i1 = 0; i1 < CURR_INST.params.int_params.param2; i1 ++){
      fprintf(vm_out, "[%"FY_PRINT32"d]", spp[i1].ivalue);
    }
    fputc(' ', vm_out);
  }
#endif
  fy_heapBeginProtect(context);
  ir = fy_heapMultiArray(context, clazz1, CURR_INST.params.int_params.param2, fy_stack_item2iarray(spp - 1),
      exception);
  FY_THEH()
}




\ #     # #######    #    ######
\ #     # #         # #   #     #
\ #     # #        #   #  #     #
\ ####### #####   #     # ######
\ #     # #       ####### #
\ #     # #       #     # #
\ #     # ####### #     # #

new ( -- ir)
{
  fy_class *clazz1;
  clazz1 = CURR_INST.params.clazz;
  if (unlikely(clazz1->accessFlags
      & (FY_ACC_INTERFACE | FY_ACC_ABSTRACT))) {
#ifdef FY_LATE_DECLARATION
    char msg[256];
#endif
    fy_strSPrint(msg, 256, clazz1->className);
    fy_fault(exception, NULL, "InstantiationErro %s", msg);
    FY_THEH();
  }
  //!CLINIT
  fy_localToFrame(context, frame);
  FY_ENGINE_CLINIT(clazz1, 0);

  ir = fy_heapAllocate(context, clazz1, exception);
  FY_THEH()
}

newarray (i1 -- ir)
{
  fy_class *clazz1;
  fy_str *pstr1;
  if (unlikely(((fy_int) i1) < 0)) {
    fy_fault(exception, FY_EXCEPTION_NASE, "%d", i1);
    FY_THEH()
  }
  switch(CURR_INST.params.int_params.param1){
  case 4:
    pstr1 = context->sArrayBoolean;
    break;
  case 5:
    pstr1 = context->sArrayChar;
    break;
  case 6:
    pstr1 = context->sArrayFloat;
    break;
  case 7:
    pstr1 = context->sArrayDouble;
    break;
  case 8:
    pstr1 = context->sArrayByte;
    break;
  case 9:
    pstr1 = context->sArrayShort;
    break;
  case 10:
    pstr1 = context->sArrayInteger;
    break;
  case 11:
    pstr1 = context->sArrayLong;
    break;
  default:
    pstr1 = NULL; /*make compiler happy*/
    fy_fault(exception, FY_EXCEPTION_VM, "%d", CURR_INST.params.int_params.param1);
    FY_THEH()
    break;
  }
  clazz1 = fy_vmLookupClass(context, pstr1, exception);
  FY_THEH()
  ir = fy_heapAllocateArray(context, clazz1, i1, exception);
  FY_THEH()
}

\  #####     #     #####  #######
\ #     #   # #   #     #    #
\ #        #   #  #          #
\ #       #     #  #####     #
\ #       #######       #    #
\ #     # #     # #     #    #
\  #####  #     #  #####     #

checkcast ( -- )
{
#ifdef FY_LATE_DECLARATION
  fy_class *clazz1;
#endif
  clazz1 = CURR_INST.params.clazz;
  fy_heapCheckCast(context, sppTOS.ivalue, clazz1, exception);
  FY_THEH()
}

instanceof (i1 -- ir)
{
#ifdef FY_LATE_DECLARATION
  fy_class *clazz1, *clazz2;
#endif

  if(i1 == 0){
    ir = 0;
  } else {
    clazz1 = fy_heapGetClassOfObject(context, i1, exception);
    clazz2 = CURR_INST.params.clazz;
    FY_THEH()
    ir = fy_classCanCastTo(context, clazz1, clazz2, TRUE) ? 1 : 0;
  }
}




\ #     # ####### #     #   ###   ####### ####### ######
\ ##   ## #     # ##    #    #       #    #     # #     #
\ # # # # #     # # #   #    #       #    #     # #     #
\ #  #  # #     # #  #  #    #       #    #     # ######
\ #     # #     # #   # #    #       #    #     # #   #
\ #     # #     # #    ##    #       #    #     # #    #
\ #     # ####### #     #   ###      #    ####### #     #

monitorenter(i1 -- )
{
  ops = fy_threadMonitorEnter(context, thread, i1, ops);
  FY_CHECK_OPS(ops);
}

monitorexit(i1 -- )
{
  ops = fy_threadMonitorExit(context, thread, i1, ops, exception);
  FY_THEH()
  FY_CHECK_OPS(ops);
}


\   ###   #     # #     # ####### #    #  #######
\    #    ##    # #     # #     # #   #   #
\    #    # #   # #     # #     # #  #    #
\    #    #  #  # #     # #     # ###     #####
\    #    #   # #  #   #  #     # #  #    #
\    #    #    ##   # #   #     # #   #   #
\   ###   #     #    #    ####### #    #  #######



invokespecial ( -- )
{
  fy_localToFrame(context, frame);
  ops = fy_threadInvokeSpecial(context, thread, frame, CURR_INST.params.method, spp, ops, exception);
  FY_THEH();
  FY_CHECK_OPS_INVOKE(ops);
  FY_UPDATE_SP(context, frame);
  SUPER_END;
}

invokestatic ( -- )
{
  //!CLINIT
  fy_localToFrame(context, frame);
  FY_ENGINE_CLINIT(CURR_INST.params.method->owner, 0);
  ops = fy_threadInvokeStatic(context, thread, frame, CURR_INST.params.method, spp, ops, exception);
  FY_THEH();
  FY_CHECK_OPS_INVOKE(ops);
  FY_UPDATE_SP(context, frame);
  SUPER_END;
}

invokevirtual ( -- )
{
  fy_localToFrame(context, frame);
  ops = fy_threadInvokeVirtual(context, thread, frame, CURR_INST.params.method, spp, ops, exception);
  FY_THEH();
  FY_CHECK_OPS_INVOKE(ops);
  FY_UPDATE_SP(context, frame);
  SUPER_END;
}



\ ######  ####### ####### #     # ######  #     #
\ #     # #          #    #     # #     # ##    #
\ #     # #          #    #     # #     # # #   #
\ ######  #####      #    #     # ######  #  #  #
\ #   #   #          #    #     # #   #   #   # #
\ #    #  #          #    #     # #    #  #    ##
\ #     # #######    #     #####  #     # #     #

return ( -- )
{
#ifdef FY_LATE_DECLARATION
  fy_uint i2;
#endif

  if (unlikely(method->access_flags & FY_ACC_SYNCHRONIZED)) {
    if (method->access_flags & FY_ACC_STATIC) {
      i2 = fy_vmGetClassObjHandle(context, method->owner, exception);
      FY_THEH()
      ops = fy_threadMonitorExit(context, thread, i2, ops, exception);
    } else {
      /*CUSTOM*/
      ops = fy_threadMonitorExit(context, thread, sbase->uvalue, ops, exception);
    }
    FY_THEH()
  }
  if (unlikely(method->access_flags & FY_ACC_CLINIT)) {
    method->owner->clinitThreadId = -1;
  }
  fy_localToFrame(context, frame);
  fy_threadPopFrame(context, thread);
#ifdef VM_DEBUG
  if(vm_debug){
    if(thread->frameCount > 0){
      fprintf(vm_out, " #Return to %s @%d + %d# ", 
        fy_threadCurrentFrame(context, thread)->method->utf8Name,
        fy_threadCurrentFrame(context, thread)->lpc,
        fy_threadCurrentFrame(context, thread)->pcofs
      );
    }
  }
#endif
  SUPER_END;
  FY_FALLOUT_INVOKE;
}

ireturn (i1 -- )
{
#ifdef FY_LATE_DECLARATION
  fy_uint i2;
#endif

  if (unlikely(method->access_flags & FY_ACC_SYNCHRONIZED)) {
    if (method->access_flags & FY_ACC_STATIC) {
      i2 = fy_vmGetClassObjHandle(context, method->owner, exception);
      FY_THEH()
      ops = fy_threadMonitorExit(context, thread, i2, ops, exception);
    } else {
      /*CUSTOM*/
      ops = fy_threadMonitorExit(context, thread, sbase->uvalue, ops, exception);
    }
    FY_THEH()
  }
  fy_threadReturnInt(frame->baseSpp, i1);
  fy_localToFrame(context, frame);
  fy_threadPopFrame(context, thread);
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #Return %"FY_PRINT32"d to %s @%d + %d# ",
      sbase->ivalue,
      fy_threadCurrentFrame(context, thread)->method->utf8Name,
      fy_threadCurrentFrame(context, thread)->lpc,
      fy_threadCurrentFrame(context, thread)->pcofs
    );
  }
#endif
  SUPER_END;
  FY_FALLOUT_INVOKE;
}

lreturn (l1 -- )
{
#ifdef FY_LATE_DECLARATION
  fy_uint i2;
#endif

  if (unlikely(method->access_flags & FY_ACC_SYNCHRONIZED)) {
    if (method->access_flags & FY_ACC_STATIC) {
      i2 = fy_vmGetClassObjHandle(context, method->owner, exception);
      FY_THEH()
      ops = fy_threadMonitorExit(context, thread, i2, ops, exception);
    } else {
      /*CUSTOM*/
      ops = fy_threadMonitorExit(context, thread, sbase->uvalue, ops, exception);
    }
    FY_THEH()
  }
  fy_threadReturnLong(frame->baseSpp, l1);
  fy_localToFrame(context, frame);
  fy_threadPopFrame(context, thread);
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #Return %"FY_PRINT64"d to %s @%d + %d# ",
      fy_I2TOL(sbase->ivalue, (sbase + 1)->ivalue),
      fy_threadCurrentFrame(context, thread)->method->utf8Name,
      fy_threadCurrentFrame(context, thread)->lpc,
      fy_threadCurrentFrame(context, thread)->pcofs
    );
  }
#endif
  SUPER_END;
  FY_FALLOUT_INVOKE;
}

\ ####### #     # ######  ####### #     #
\    #    #     # #     # #     # #  #  #
\    #    #     # #     # #     # #  #  #
\    #    ####### ######  #     # #  #  #
\    #    #     # #   #   #     # #  #  #
\    #    #     # #    #  #     # #  #  #
\    #    #     # #     # #######  ## ##

athrow (i1 -- )
{
  thread->currentThrowable = i1;
  SUPER_END;
  FY_FALLOUT_NOINVOKE;
}

\       # #     # #     # ######
\       # #     # ##   ## #     #
\       # #     # # # # # #     #
\       # #     # #  #  # ######
\ #     # #     # #     # #
\ #     # #     # #     # #
\  #####   #####  #     # #

goto ( -- )
{
  FY_CHECK_OPS_AND_GOTO(ops);
}

if_icmpeq (i1 i2 -- )
{
  if(i1 == i2){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

if_icmpne (i1 i2 -- )
{
  if(i1 != i2){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

if_icmplt (i1 i2 -- )
{
  if((fy_int)i1 < (fy_int)i2){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

if_icmple (i1 i2 -- )
{
  if((fy_int)i1 <= (fy_int)i2){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

if_icmpgt (i1 i2 -- )
{
  if((fy_int)i1 > (fy_int)i2){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

if_icmpge (i1 i2 -- )
{
  if((fy_int)i1 >= (fy_int)i2){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

ifeq (i1 -- )
{
  if(i1 == 0){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

ifnull (i1 -- )
{
  if(i1 == 0){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

ifne (i1 -- )
{
  if(i1 != 0){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

ifnonnull (i1 -- )
{
  if(i1 != 0){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

iflt (i1 -- )
{
  if((fy_int)i1 < 0){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

ifle (i1 -- )
{
  if((fy_int)i1 <= 0){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

ifgt (i1 -- )
{
  if((fy_int)i1 > 0){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

ifge (i1 -- )
{
  if((fy_int)i1 >= 0){
    FY_CHECK_OPS_AND_GOTO(ops);
    INST_TAIL;
  }
  SUPER_CONTINUE;
}

lookupswitch (i1 -- )
{
#ifdef FY_LATE_DECLARATION
  fy_uint i2, i3;
  fy_switch_lookup *swlookup;
#endif
  swlookup = CURR_INST.params.swlookup;
  i3 = swlookup->count;
  for(i2 = 0; i2 < i3; i2++){
    if(swlookup->targets[i2].value == i1){
      SET_IP(swlookup->targets[i2].target);
      INST_TAIL;
      break;
    }
  }

  SET_IP(swlookup->defaultJump);
}

tableswitch (i1 -- )
{
#ifdef FY_LATE_DECLARATION
  fy_uint i2, i3;
#endif
  i2 = CURR_INST.params.swtable->lowest;/*lb*/
  i3 = CURR_INST.params.swtable->highest;/*hb*/
  if ((fy_int) i1 < (fy_int) i2
      || (fy_int) i1 > (fy_int) i3) {
    SET_IP(CURR_INST.params.swtable->defaultJump);
    INST_TAIL;
  } else {
    SET_IP(CURR_INST.params.swtable->targets[i1 - i2]);
    INST_TAIL;
  }
}



\ #     # ####### ####### ######
\ ##    # #     # #     # #     #
\ # #   # #     # #     # #     #
\ #  #  # #     # #     # ######
\ #   # # #     # #     # #
\ #    ## #     # #     # #
\ #     # ####### ####### #

pop (i1 -- )
;

pop2 (i1 i2 -- )
;


\ #     # #     # ####### ######  #######
\ #     # ##    # #     # #     #    #
\ #     # # #   # #     # #     #    #
\ #     # #  #  # #     # ######     #
\ #     # #   # # #     # #          #
\ #     # #    ## #     # #          #
\  #####  #     # ####### #          #


ldc ( -- ir)
{
  ir = opLDC(context, method->owner, CURR_INST.params.ldc.value, exception);
  FY_THEH()
  MODIFY_CURR_INST(sipush);
  CURR_INST.params.int_params.param1 = ir;
}

ldc2_w ( -- lr)
{
  lr = opLDC2(context, method->owner, CURR_INST.params.ldc.value, exception);
  FY_THEH()
  MODIFY_CURR_INST(slpush);
  CURR_INST.params.int_params.param1 = fy_HOFL(lr);
  CURR_INST.params.int_params.param2 = fy_LOFL(lr);
}

getfield (i1 -- ir)
{
  fy_field *field;
  field = CURR_INST.params.field;
  if (unlikely(field->access_flags & FY_ACC_STATIC)) {
    fy_fault(exception, FY_EXCEPTION_INCOMPAT_CHANGE, "field %s is static", field->utf8Name);
    FY_THEH()
  }
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getfield %s from #%"FY_PRINT32"d# ", field->utf8Name, i1);
  }
#endif
  ir = fy_heapGetFieldInt(context, i1, field, exception);
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #value=%"FY_PRINT32"d# ", ir);
  }
#endif
  FY_THEH()
  MODIFY_CURR_INST(getfield_n);
}

putfield (i1 i2 --)
{
  fy_field *field;

  field = CURR_INST.params.field;
  if (unlikely(field->access_flags & FY_ACC_STATIC)) {
    fy_fault(exception, FY_EXCEPTION_INCOMPAT_CHANGE, "field %s is static", field->utf8Name);
    FY_THEH()
  }
  if (unlikely((field->access_flags & FY_ACC_FINAL) && method->owner != field->owner)) {
    fy_fault(exception, FY_EXCEPTION_ACCESS, "field %s is final", field->utf8Name);
    FY_THEH()
  }
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #putfield %s to #%"FY_PRINT32"d value=%"FY_PRINT32"d# ", field->utf8Name, i1, i2);
  }
#endif
  fy_heapPutFieldInt(context, i1, field, i2, exception);
  FY_THEH()
  MODIFY_CURR_INST(putfield_n);
}

getfield_x (i1 -- lr)
{
  fy_field *field;
  field = CURR_INST.params.field;
  if (unlikely(field->access_flags & FY_ACC_STATIC)) {
    fy_fault(exception, FY_EXCEPTION_INCOMPAT_CHANGE, "field %s is static", field->utf8Name);
    FY_THEH()
  }
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getfield %s from #%"FY_PRINT32"d# ", field->utf8Name, i1);
  }
#endif
  lr = fy_heapGetFieldLong(context, i1, field, exception);
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #value=%"FY_PRINT64"d# ", lr);
  }
#endif
  FY_THEH()
  MODIFY_CURR_INST(getfield_nx);
}

putfield_x (i1 l1 --)
{
  fy_field *field;

  field = CURR_INST.params.field;
  if (unlikely(field->access_flags & FY_ACC_STATIC)) {
    fy_fault(exception, FY_EXCEPTION_INCOMPAT_CHANGE, "field %s is static", field->utf8Name);
    FY_THEH()
  }
  if (unlikely((field->access_flags & FY_ACC_FINAL) && method->owner != field->owner)) {
    fy_fault(exception, FY_EXCEPTION_ACCESS, "field %s is final", field->utf8Name);
    FY_THEH()
  }
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #putfield %s to #%"FY_PRINT32"d value=%"FY_PRINT64"d# ", field->utf8Name, i1, l1);
  }
#endif
  fy_heapPutFieldLong(context, i1, field, l1, exception);
  FY_THEH()
  MODIFY_CURR_INST(putfield_nx);
}

getstatic( -- ir)
{
#ifdef FY_LATE_DECLARATION
  fy_field *field;
  fy_class *clazz1;
#endif
  field = CURR_INST.params.field;
  clazz1 = field->owner;
  if (unlikely(!(field->access_flags & FY_ACC_STATIC))) {
    fy_fault(exception, FY_EXCEPTION_INCOMPAT_CHANGE, "field %s is not static", field->utf8Name);
    FY_THEH()
  }
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getstatic %s# ", field->utf8Name);
  }
#endif
  //!CLINIT
  fy_localToFrame(context, frame);
  FY_ENGINE_CLINIT(clazz1, 0);
  ir = fy_heapGetStaticInt(context, field, exception);
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getstatic %s value=%"FY_PRINT32"d# ", field->utf8Name, ir);
  }
#endif
  FY_THEH()
  MODIFY_CURR_INST(getstatic_n);
  CURR_INST.params.isfield = field->owner->staticArea + field->posAbs;
}

putstatic(i1 -- )
{
#ifdef FY_LATE_DECLARATION
  fy_field *field;
  fy_class *clazz1;
#endif
  
  field = CURR_INST.params.field;
  if (unlikely((field->access_flags & FY_ACC_FINAL) && (field->owner != method->owner))) {
    fy_fault(exception, FY_EXCEPTION_ACCESS, "");
    fy_strSPrint(exception->exceptionDesc, sizeof(exception->exceptionDesc), field->uniqueName);
    FY_THEH()
  }
  clazz1 = field->owner;
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #to putstatic %s value=%"FY_PRINT32"d# ", field->utf8Name, i1);
  }
#endif
  //!CLINIT
  fy_localToFrame(context, frame);
  FY_ENGINE_CLINIT(clazz1, 1);
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #putstatic %s value=%"FY_PRINT32"d# ", field->utf8Name, i1);
  }
#endif
  fy_heapPutStaticInt(context, field, i1, exception);
  FY_THEH()
  MODIFY_CURR_INST(putstatic_n);
  CURR_INST.params.isfield = field->owner->staticArea + field->posAbs;
}

getstatic_x( -- lr)
{
#ifdef FY_LATE_DECLARATION
  fy_field *field;
  fy_class *clazz1;
#endif
  field = CURR_INST.params.field;
  clazz1 =  field->owner;
  if (unlikely(!(field->access_flags & FY_ACC_STATIC))) {
    fy_fault(exception, FY_EXCEPTION_INCOMPAT_CHANGE, "field %s is not static", field->utf8Name);
    FY_THEH()
  }
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getstatic %s# ", field->utf8Name);
  }
#endif
  //!CLINIT
  fy_localToFrame(context, frame);
  FY_ENGINE_CLINIT(clazz1, 0);
  lr = fy_heapGetStaticLong(context, field, exception);
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #getstatic %s value = %"FY_PRINT64"d# ", field->utf8Name, lr);
  }
#endif
  FY_THEH()
  MODIFY_CURR_INST(getstatic_nx);
  CURR_INST.params.isfield = field->owner->staticArea + field->posAbs;
}

putstatic_x(l1 -- )
{
#ifdef FY_LATE_DECLARATION
  fy_field *field;
  fy_class *clazz1;
#endif

  field = CURR_INST.params.field;
  if (unlikely((field->access_flags & FY_ACC_FINAL) && (field->owner != method->owner))) {
    fy_fault(exception, FY_EXCEPTION_ACCESS, "");
    fy_strSPrint(exception->exceptionDesc, sizeof(exception->exceptionDesc), field->uniqueName);
    FY_THEH()
  }
  clazz1 = field->owner;
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #to putstatic %s value=%"FY_PRINT64"d# ", field->utf8Name, l1);
  }
#endif
  //!CLINIT
  fy_localToFrame(context, frame);
  FY_ENGINE_CLINIT(clazz1, 2);
#ifdef VM_DEBUG
  if(vm_debug){
    fprintf(vm_out, " #putstatic %s value=%"FY_PRINT64"d# ", field->utf8Name, l1);
  }
#endif
  fy_heapPutStaticLong(context, field, l1, exception);
  FY_THEH()
  MODIFY_CURR_INST(putstatic_nx);
  CURR_INST.params.isfield = field->owner->staticArea + field->posAbs;
}

\ ######  ####### #     # ######  #       #######
\ #     # #     # #     # #     # #       #
\ #     # #     # #     # #     # #       #
\ #     # #     # #     # ######  #       #####
\ #     # #     # #     # #     # #       #
\ #     # #     # #     # #     # #       #
\ ######  #######  #####  ######  ####### #######

dadd (d1 d2 -- dr)
{
  dr = d1 + d2;
}

dsub (d1 d2 -- dr)
{
  dr = d1 - d2;
}

ddiv (d1 d2 -- dr)
{
  dr = d1 / d2;
}

dmul (d1 d2 -- dr)
{
  dr = d1 * d2;
}

drem (d1 d2 -- dr)
{
  if(d2 == 0){
    dr = 0.0 / d2;
  } else {
    dr = d1 - floor(d1 / d2) * d2;
  }
}

dneg (d1 -- dr)
{
  dr = -d1;
}

dcmpg (d1 d2 -- ir)
{
  if (unlikely(fy_isnand(d2) || fy_isnand(d1))) {
    ir = 1;
  } else {
    ir = d1 == d2 ? 0 : (d1 - d2 > 0) ? 1 : -1;
  }
}

dcmpl (d1 d2 -- ir)
{
  if (unlikely(fy_isnand(d2) || fy_isnand(d1))) {
    ir = -1;
  } else {
    ir = d1 == d2 ? 0 : (d1 - d2 > 0) ? 1 : -1;
  }
}

dropout ( -- )
{
  #ifdef VM_DEBUG
  if (vm_debug) {
  fputs(" ### ", vm_out); fputc('\n', vm_out);
  }
  #endif
  goto label_fallout_invoke;
}

\C#ifdef FY_ENGINE_HEADER
\C    label_fallout_invoke:
\C#ifdef FY_INSTRUCTION_COUNT
\C    context->last_op = 0x1ff;
\C#endif
\C    return ops;
\C  }
\C}
\C#undef FY_ENGINE_NAME
\C#endif

